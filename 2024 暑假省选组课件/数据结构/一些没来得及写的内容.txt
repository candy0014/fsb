------------
并查集

对于动态树，其实由于 lct 等超纲，会写 ETT 且能比较好地用并查集即可，如果真需要 lct 甚至 WBTT 可以现场瞎写。

并查集在线的情况下有反阿克曼函数的下界（注意 wikipedia 上的叙述有点问题，应该用二元的，在 n,m 同阶时才也可以用一元的），与路径压缩按秩合并的并查集相同。

证复杂度实际上只需要：所有合并操作构成的有根树中，高度超过 i 的结点不超过 b*n/a^i，其中 a,b 为常数，a>1。

离线的话可以先得到一棵最终的树，按套路用四毛子做到线性，注意在一条链的情况下（即每次合并相邻两个元素），等效于直接使用压位，并不难写且应该有一定的效率提升，不过一般卡常之前也不必去动。

带权并查集：每个结点有一个权值（在某半群中），初始没有边（始终构成有根森林），每次可以修改某个根的权值，将一个根设为另一个结点的儿子，查询一个结点的到根链和（半群运算）。

在一些在线情况（每个元素可逆或为零（视叙述的左逆或右逆，仍按秩合并），半群为全序集下的最小值（维护类单调栈结构））仍能做到反阿克曼。

-----------
KTT

一些 EI 没提到的有用情况下实际上也可以做到少一个 log，并且在单 log 的情况下 KTT 看起来常数还比较小。

---------
簇

从树形 dp 开始，子树就是树相关题目的常见考察对象，其中一个比较本质的原因即为子树中结点与外部尚未考虑到的结点之间的路径一定会经过子树的根。

子树可以扩展为以下操作组成的结构（注意下面的“子树”可能是某个子图的子树，而非原树的子树）：
1. 一个结点 u 可以构成一个根为 u 的子树。
2. 一个根为 u 的子树 S_1，一个根为 v 的子树 S_2，若 u 是 v 的父亲且 S_1,S_2 无交（只需 v 不在 S_1 中），S_1, S_2 可以拼接得到一个根为 u 的子树（点集与边集取并，并加上两个根之间的父子边）。

但在一些动态的情况下，维护子树结构（实际上基本等效于原树结构），可能没有较好的时间复杂度。

因此我们可以进行扩展，允许维护一个有两个界点的结构：
1. 一条边可以构成界点为两个端点的簇（边集为这条边，内部点集为空集）。
2. 对于两个有且仅有一个公共界点 u 且边集无交（显然内部点集也无交）的簇，
2.1. (compress) 可以将 u 和内部点集之并作为新的内部点集，边集之并作为新的边集，去掉两个 u 后的剩余两个界点作为新的界点，得到一个新的簇。
2.2. (rake) 可以将一个簇的界点作为新的界点，边集之并作为新的边集，内部点集之并与另一个簇的界点作为新的内部点集，得到一个新的簇。
3. (twist, 对于原图是树并不需要) 对于公共界点集相同的两个簇，将内部点集与边集分别取并，得到一个新的簇。

我们将叶子结点对应若干条边，每个结点对应两个儿子对应簇进行上述操作得到的簇（显然每个结点会有一个操作类型）的二叉树成为其根结点对应簇的 top tree。

链分治可以比较好的刻画 top tree 的结构，全局平衡二叉树等链分治的分治树经过一定的格式调整即可得到一棵树高为 O(log n) 的 top tree（事实上正常使用中两者并没有多大区别，可能链分治一般习惯将点作为基础，而 top tree 使用边）。

绝大多数简单信息（如链、子树的权值半群和、权值最大子段和、直径等）都可以对一个簇维护 O(1) 的信息，并且支持上述三种操作的合并。

此外 lca，重心等也可以通过维护简单信息进行非局部搜索在树高的时间复杂度内得到，具体方式可以参见 https://negiizhao.blog.uoj.ac/blog/4912。

当然对于广义串并联图（包含仙人掌等），都可以建出 top tree，但不一定平衡，可能需要再次使用树上技巧。

一般在有根树中可以强制规定界点为祖先后代简化情况，事实上倍增 dp 基本上也可以视为维护每个结点与其二的幂级祖先为界点的某簇的信息。

---------
虚树

在 noi 闭幕式日的某次线上私聊中，虚树是一种特殊的离散化，得到了某国家队的赞同，认为这是一个比较深刻的理解。

---------
树链剖分、树分治、动态树

虽然树链剖分的部分入门应用只需视作 dfs 序的一些性质应用，但更高级的一些技巧则完全应当视作树分治的一种。

树分治大概就是选一个（点、边、链等）作为分治中心，然后将分治中心从树中删去后会形成若干连通块，然后对连通块进一步进行分治。

事实上，可以类比序列上的简单分治、线段树、平衡树，去理解树分治、树分治的分治树、树分治的动态分治树。

对于涉及到距离定结点不超过定距离构成的连通块、某等价关系构成的连通块等，往往可以通过点分治求解，[ynoi]成都七中。此外，一些路径问题也经常通过点分治求解。

边分治，复杂度额外多 log(度数)，但往往会进行三度化。对于可以三度化的情况，一般可以进行点分治再通过启发式合并做到每次合并两个连通块，达到相同的效果。

链分治，一般来说对链会进一步执行序列分治，对轻儿子也可能进行集合分治。分治时可以根据下面所有点的个数而不只是按照序列中点，容易说明前者可以做到分治树高 O(log n)，即全局平衡二叉树。

树分治的分治树（点分树，边分树……）大概就是类似线段树，将分治的结构通过分治树维护，并且类似线段树一次操作可以做到基本只往单侧递归，其余部分通过维护信息或懒标记解决。细节可以参考具体题目的题解。

点分治，点分树题目：[清华集训2016] 汽水，[NOI2014] 购票，[PA2017] Banany，soj68 斐波那契树。

[WC2018] 通道，多棵树的问题有时可以在第一棵树上跑树分治，然后通过建立虚树转化为少一棵树的情况，代价是多一个 log。

[CTSC2018] 暴力写挂。

[WC] 紫荆花之恋，动态点分树，考虑将替罪羊树作为类比的平衡树，我们无视每次强制取重心作为分治中心的限制，维护一棵点分树，然后在某个结点不平衡时暴力对子树进行重构。[WC] 即时战略也可以使用动态点分树。

ETT 大概就是直接用平衡树维护 dfs 序，其余和一棵静态树维护 dfs 序的方法区别不大。

LCT，比较重要的是其时间复杂度分析：一棵树，每次将一个结点的到根链染成一个新的颜色，其颜色段均摊为多一个 log（注意链没有这个 log），如果要用 treap 实现可以类似 WBTT，将一个结点在链的平衡树中用于比较的随机权值改为其轻子树与自身随机权值的最大值，当由于换根等不方便维护时可以考虑用某不会证不会卡的经典方法：改为按大小为权随机比较。

WBTT，我们考虑用 treap 作为类比的平衡树，考虑一种随机剖分方式（WC2021 的课件里有写过）：先对每个结点进行随机赋权，然后对每个结点选取子树内随机权值最大的一个作为重儿子。同时对每条重链和每个结点的轻儿子集合用 treap 维护（treap 中随机权值为轻子树与自身权值最大值），可以做到严格单 log 的动态树，可以参见 [CTS2022]WBTT 与命题人 zx2003 在 uoj 写的博客。

可以注意到，如果将链分治中每条链进一步序列分治的分治点作为点分治的分治中心，链分治可以视为一种限制更强的点分治，因此在上述三个树分治中链分治是最强的。

top tree 比链分治略弱（或者说链分治的分治树是一种限制更强的 top tree），但往往足够解决问题。

线段树的一些技巧往往也可以直接套到树分治的分治树上，以猫树（基于线段树的二区间合并）为例：

对于一条链，可以在分治树中自底向上找到两个端点对应结点的最近公共祖先，并沿该结点的分治中心将链拆成两条，每条都可以表示为一个结点到其分治树某祖先的分治中心的形式。

对于距离定结点不超过定距离的邻域，可以在分治树中自底向上找到完全包含于该邻域的最后一个结点，邻域可以拆为该结点对应簇与两个界点的某簇外邻域，且邻域距离不超过分治树兄弟结点的直径，因此堆该结点对应簇的两个界点与可能需要的距离维护定距离邻域情况即可，可以参见 [NOI2022] 树上邻域数点。

关于长链剖分有一个类似直径的性质：选 i 个最长的方案包括选 i - 1 个最长的方案，然后可以通过长剖刻画。

（未完待续，dsu on tree（树上启发式合并）与静态链分治的等价性）

（枚举操作时间）维护树上信息在一些情况下也可以转置为枚举树上结点，用线段树等序列数据结构维护操作时间对应信息，可以参见线段树课件中 SSBR#2 的钱哥题。

----------

树上分块及莫队

树上分块相关内容可以参见周欣的国集论文。

树上分块可以通过设定每个簇的最大大小阈值，自底向上通过贪心得到一个满足大小限制，个数限制的每一个块是一个簇的树分块，如果允许不止两个界点的“伪簇”，分块部分代码可以略为简化。

此外，可以类比基于线段树的分块，在 top tree 上直接节选子树大小不超过某阈值的极高结点。

序列上定区间长度 k 的问题按 k 分块的解法同样可以直接套到树上，[十二省联考 2019] 希望。

此外，注意在树剖上直接分块的复杂度，O(sqrt(n)+sqrt(n/2)+...)=O(sqrt(n))。

树上莫队对于直接可以 dfs 序上处理的问题当然可以直接通过 dfs 序完成。

lxl 还给出了一种双子树莫队：

（未完待续）

----------
Misc

soj1095 数据恢复，序列调整法得到全序进行排序的算法加上树形依赖后的版本，同样使用调整法，说明每次最小的一定紧随其父亲，可以进行等效处理为一个新的结点，使用优先队列维护。

（想起来了再补）